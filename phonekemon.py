
from itertools import combinations

#의사 코드 + 메모
#
# 1차원 배열
# 길이는 항상 짝수
# 종류 번호는 1이상 200000미만
# 그 최대 개수를 리턴한다
# 반드시 폰켓몬 수만큼을 골라야한다
#
#
# N/2 마리를 선택해야한다
#
# N/2 를 선택하는 방법의 수
#
# 종류 수의 최댓값을 구해야함
#
# 가장 많은 종류의 폰켓몬을 선택하기를 원한다
#
# 길이C길이/2 하여
#
# 나열된 방법의 수를 세트로 변환한 최댓값을 리턴한다
# 브루트 포스말고
#
# combinations를 쓰면 중복된 세트 요소가 나오니까 완전탐색을 하게 된다 그렇다면 다른 방법을ㄹ
#
# 전처리를 먼저 해볼까
#
# 중복을 다 제거하고 나서 개수를 보자 중복 제거해서 선택할수 있는 경우가 가능하다면
#
# 중복이 제거 된 상태니까 그대로 리턴하고 모자르다면 모자른 종류 수 만큼 선택할 수 있는 지를 보면서 종류 수를 줄여나가는 방법
#
# nums = [3,1,2,3]
#
# count  = int(len(nums)/2)
#
# 만약 3333 이고 2개를 선택해야되는데 종류가 1개라면?
# 원래 리스트에서 2개를 선택하면된다
# 333222 에서
#
# 32 니까
# 원래 리스트에서
# ;
# 세트에서 개수가 모자른 경우고
# 개수가 모자른 경우
#
# 모자르지 않은 경우는 선택하면된다



# set  한 다음에 각 요소를 카운트한다 .
# 그 다음 카운트 수만큼 빼오면되겟네 역시읽으면 인사이트가 나온다
#
# 공간복잡도에서도 좋지 않다
#
#최대 종류 수 int(len(nums))
#
#set(nums)

#count(nums[0]) 그리고 각 세트의 카운트가 개수를 넘기만 하면 선택하는 걸로 하니까 그러면 되겟네
#아니면 종류 수 줄여나가고

#

#
else:

    result = int(len(set(nums)) / count)
def solution(nums):


    answer = 0
    return answer

#    N/2 = 2

# if else 대신 값을 넣어주는 것
# 난 너무 어렵게 생각했다 -> 이유 set로 줄였을 때 이미 개수는 정해져있고 종류가 한정된 거니까. 문제에서 원하는 건 종류니가 문제의 눈으로 풀자
# 종류를 리턴해주면 됬다 그리고 조합 개념이 정확해야 했다 선택한다고 가정하면 선택하는 거니까 그게 실제다


def solution(nums):
    set_nums = set(nums)
    count = len(nums)//2
    result = 0
    if set_nums > count:
        result = count
    else:
        # 미완성 풀이 나는 여기서 현재 set 종류의 각각의 개수만으로 count를 넘길 수 있는 지 체크하려고 했다. 조합의 개념활용 부족
        # 개념 활용해서 문제 푸는 습관 필요
        count -= 1 #?
        #for i in range(len(set_nums)):


    return result

    # 다른 사람 best 풀이
    #return min(len(ls)/2, len(set(ls)))
