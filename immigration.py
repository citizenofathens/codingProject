



if __name__ == '__main__':

    # 문제에서 주어진 힌트와 조건
    # 문제의 목적이 총 시간을 구하는 것이므로 이에 따라 최대 시간과  최소 시간으로 나눈 후 가능한 최소시간을 이분 탐색으로 찾는 시도를 할 수 있다
    # 문제 자체가 시간이 주어지고 시간을 구하라고 하는 것이 목적이기 때문에 이러한 전략을 세우고
    # 이분탐색이라는 알고리즘을 떠올려 사용할 수 있도록 함

    def solution( n , times):

        l_idx = 1 # 최소시간
        r_idx = max(times) * n # 가장 오래 걸리는 심사대가 모든 사람을 처리하는 것이 가장 오래 걸리는 방법이다 .


        # 목표 시간을 찾기 위해서는 l_idx가 r_idx가 커지는 순간 이전 까지이다


        # 더 이상 심사시간을 줄일 수 없을 때
        # l_idx = mid + 1은 처리할 수 있는 심사대보다 인원이 많으므로 심사대를 늘리는 것을 뜻한다
        # r_idx = mid - 1은 시간 동안 인원보다 처리 할 수 있는 심사대가 더 많아 심사대를 줄여 시간을 줄이는 것을 뜻한다
        #
        while l_idx <= r_idx:
            task_sum = 0
            mid = (l_idx + r_idx) // 2

            for time in times:
                task_sum += mid // time # task_sum 은 타겟 시간을 시간이 가장 적게 걸리는 심사대부터 n번 반복하여 처리한 횟수
                                        #가능한 최소 시간을 탐색해나가는 기법

            if task_sum < n: # 각 심사대가 처리한 횟수가 전체인원보다 부족하다면 총 시간을 늘린다
                l_idx = mid +1
            else:
                r_idx = mid - 1   # 각 심사대가 처리한 횟수가 전체인원보다 많다면 총 시간을 줄인다
                if mid < r_idx:
                    answer = mid

        return answer

